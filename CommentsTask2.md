1. По пункту 3, прояснение - уточняем комментарием причину установки нулевого таймаута для платформы:
   ```
   // Eсли это IOS сборка запущенная на MacOS, то отключаем определение таймаута при покупке, т.к. 
   // ухода в паузу в момент покупки на MacOS не происходит
   responceTimeout = NativeUtils.IsiOSAppOnMac() ? 0 : ClientConfiguration.BillingResponseTimeout;

   billingService.SetBillingResponseTimeout(responceTimeout);
   ```
   
2. По пункту 2, представление намерений - в методе наведения орудий при расчёте угла наведения необходимо делать коррекцию угла через проекцию вектора направления орудия на плоскость.
   ```
   // Если ось direction будет в направлении ствола юнита, то проекция цели на плоскость, образованную direction, orientation и M3
   // не всегда будет представлять реальное положение цели. Поэтому, для корректного вычисления угла поворота, нужно повернуть сам direction
   // по оси orientation в направлении цели с сохранением положения. 
   direction = AdjustDirectionToTargetOnAxis(direction, Weapon.Target.TargetPosition, orientation);
   
3. По пункту 4, предупреждение о последствиях - проверка выполняется в объекте контроллера состояний слотов. Код находится в методе обработчика события смены бинда слота:
   ```
    // Принудительный бинд возможен только при восстановлении боя из снапшота
	// Проверка обязательна т.к. при восстановлении из снепшота может заблокироваться слот, поскольку юнит может не прийти
    if (!isForceBind)
	{
		boundSlot.ChangeState(SlotState.WaitingForTraining);
	}
   ```
   
4. По пункту 1 - информационный комментарий. - В классе ответственном за отправку уведомлений жёстко задано за сколько минут до начала боя отправляются такие уведомления. 
   Добавлен комментарий, который поясняет на основе чего построен такой список:
   ```
    // Время отправки уведомлений выбрано согласно решению ГД, описано в ГДД (url на гдд)
		private IReadOnlyList<TimeSpan> _notificationTimes = new[]
		{
			new TimeSpan(0, 5, 0),
			new TimeSpan(0, 3, 0),
			new TimeSpan(0, 2, 0),
			new TimeSpan(0, 1, 0)
		};
   ```
   
5. По пункту 5 - усиление. В классе, описывающем уведомление об игровой активности (пвп, пве и т.д.) добавлен комментарий дополнительно объясняющий зачем сообщение должно быть локализовано:
   ```
   public sealed class ActivityNotification
	{
		... // Поля и свойства уведомления

		
		// Сообщение должно быть уже локализовано т.к. именно в таком виде отобразится игроку
		public string LocalizedActivityDescription { get; }

		... // Конструктор уведомления
	}
   ```
   
6. По пункту 1 - информационные комментарии. Уточняем значение параметров перечисления? которое используется для настройки орудий юнита.  
   ```
   public enum WeaponForUnitState : byte
	{
		// Принадлежность орудия к обоим состояниям юнита и к нормальному и специальному. Орудие активно всегда.
		Both,
   
		// Принадлежность орудия только к нормальному состоянию юнита. Когда юнит находится в специальном состоянии, орудие деактивируется.
		NormalState,

		/// Принадлежность орудия только к специальному состоянию юнита. Когда юнит находится в нормальном состоянии, орудие деактивируется.
		SpecialState
	}
   ```
   
7. По пункту 6 - todo. Для обновления всй бд временно на начальном этапе выделил отдельный метод который из потока извлекал все данные и перезаписывал их в бд. Но были планы переехать с EXCEL формата хранения на SQL.
   ```
   //todo Отрефакторить в версии бота 1.2.0
    public async ValueTask<bool> TryUpdateDatabaseAsync(Stream stream, CancellationToken cancellationToken)
    {
        ... // Логика апдейта информации о расписании в БД
    }
   ```
   
8. По пункту 1 - информационный комментарий. Есть класс, который отслеживает не остановленные UniTask между сценами в юнити для того, чтобы избегать утечек памяти в неостановленных тасках. 
   В нём есть обработчик события который при смене сцены находит неостановленные таски. Поясним в комментарии суть его работы:
   ```
   
   // Часто таски сразу после переключения сцен еще живут т.к. останавливаются не мгновенно,
   // для корректности расчёта делаем снимок тасок которые живы сразу после старта новой сцены, 
   // а затем проверяем через интервал CHECK_UNITASKS_DELAY_SECONDS какие были остановлены.
   private void OnActiveSceneChangedHandler()
	{
		... // Обработка неостановленных тасок
	}
   ```
   
9. По пункту 4 - предупреждение о последствиях. Есть метод проверки доступности рекламы на экране соревнования. 
   Добавили предупреждающий комментарий о том почему нельзя показывать рекламу при запущенном матчинге: 
   ```
   public bool CheckAdsShowAvailable()
    {
    	// Нельзя смотреть рекламу в момент поиска боя, т.к. игрок может пропустить начало боя поскольку экран будет закрыт веб окном рекламы.
    	if (IsSearchMatchingOrLobby())
    	{
    		return false;
    	}
       
    	... // Остальные проверки
       
    	return true;
    }
   ```
   
10. По пункту 4 - предупреждение о последствиях. Из примера в п.9 также предупреждаем почему мы не можем показать игрокам на ios в этом месте рекламу:
    ```
    public bool CheckAdsShowAvailable()
    {
        ... //
        
 	    // Если включена опция ограничения трекинга рекламы и это не iOS14 или выше, 
        // то согласно требованиям apple мы также не можем показать такую рекламу в этом месте.
 	    if (IsAdvertisingTrackingEnabled && !NativeUtils.IsIOS14 && !NativeUtils.IsiOSAppOnMac)
 	    {
 	    	return false;
 	    }
        
 	    return true;
    } 
    ```
    
11. По пункту 6 - todo. Есть метод инициализации всех модулей бота. Добавим todo в котором отметим как изменится инициализации в следующей версии:
    ```
    // todo: С версии бота 1.3.0 инициализация перейдёт в сервис инициализации бота
    private static async Task<bool> TryInitializeAll(List<IInitializable> initializables)
    {
        bool result = true;
        
        foreach (IInitializable initializable in initializables)
        {
            try
            {
                await initializable.Initialize(CancellationToken.None);
            }
            catch (Exception e)
            {
                Logger(LogLevel.Exception,
                    $"Exception during initialization \"{initializable.GetType().Name}\": {e.Source} {e.Message}");
                result = false;
                break;
            }
    
            if (!initializable.IsInitialized)
            {
                Logger(LogLevel.Error, $"Initializable object not initialized: {initializable.GetType().Name}");
                result = false;
            }
        }
    
        return result;
    }
    ```
    
12. По пунктам 1 и 5 - информирование и усиление. Информируем для чего использован деконструктор и почему он важен.
    ```
    // Нужно только для безопасной работы со статическим эвентом из подсистемы юнити в редакторе, 
    // предотвращает повторную подписку и NullReferenceException
    #if UNITY_EDITOR
       ~WaitingWindowSceneTrackerDecorator()
       {
          SceneManager.activeSceneChanged -= OnActiveSceneChanged;
       }
    #endif
    ```

